# B tree

B tree는 AVL트리와 같은 BALANCED TREE이다.
자식을 두개만 가지는 이진트리의 단점을 보완할 수 있다.
삽입 삭제 이후에도 균형 트리를 유지한다.

구현 : https://velog.io/@seanlion/btreeimplementation

# B tree의 규칙

- 노드의 데이터 수가 최대 N -> 자식의 수는 N+1

이런 얘기이다..

	ㅁㅁ
ㅁ	ㅁ	ㅁ

- 각 노드의 데이터는 정렬된 상태
- leaf node는 모두 같은 레벨이다. -> 완전한 균형 트리 형태 유지 // AVL트리의 경우 일정수준까지 균형 인수가 그대로이면 균형잡기 함수를 안쓰는데, 비트리는 애초부터 리프노드가 모두 같은 레벨인 것으로 정한다.
- 특정한 데이터의 왼쪽 서브 트리는 해당 데이터보다 작으며, 오른쪽 서브 트리는 해당 데이터보다 크다. // AVL트리, 이진트리와 일치한다.
- 루트 노드는 최소한 2개 이상의 자식을 가진다.
- 루트와 리프 노드를 제외한 노드는 최소한 {(차수)/2}개의 올림 만큼의 자식을 가지고 있다. // 차수는 DEGREE : 자식의 수 이다. 만약 차수가 3이면, 자식의 수가 3이므로(최소한 2개의 자식을 가진다.), 노드에 들어가는 데이터의 수가 2개라는 것이다.
- 데이터에 중복이 없다고 가정한다.

# 균형트리(Balanced Tree)

AVL트리, 2-3트리, 2-3-4트리 등이 있다.
데이터베이스는 많은 데이터를 포함하고 있어, B Tree를 채택하고 있다.

자식의 개수가 많아질수록 소모되는 메모리 용량이 크다. 다만 더 빠르게 데이터에 접근할 수 있게된다.

# 삽입 예제

7

5삽입
57

6삽입
567

6상승 및 나머지 분할
	6
5		7

4삽입
	6
45		7

3삽입
	6
345		7


	46
35		7

	46
3	 5	7

8,9삽입

	46
3	 5	789

	468
3	 5	79

	 6
	48
3	 5	79

	 6
	4	8
3	 5		79

	 6
	4	8
3	 5		7	9


이런식으로 재귀적으로 중간 데이터를 위로 올리고 나머지를 분할 하는 것을 반복하자.

# B Tree의 삭제는 회전과 병합을 통해서 이루어진다.
같은 노드에 데이터가 존재하면 그냥 바로 삭제하면 된다.

6삭제 : 삭제 전에 형제노드에 가져올 수 있는 데이터가 있는지 확인 -> 회전 수행

	 5
	3	7
12	 4		6	89

	 5
	3	7
12	 4			89

	 5
	3	
12	 4		7	89

	 5
	3	  8
12	 4	7	9

7삭제 : 가져올수 없으면 병합을 시도

	 5
	3	  8
12	 4	7	9

	 5
	3	  8
12	 4		9


	 5
	3	  
12	 4		89
삭제처리된 노드를 지워준다. 재귀적으로 병합을 한다.

	 
	35	  
12	 4		89

1삭제

	35	  
2	 4		89

2삭제

	5	  
34		89

B tree Visualization을 검색해서 재현해보자.